{"version":3,"sources":["webpack://millan.[name]/webpack/universalModuleDefinition","webpack://millan.[name]/webpack/bootstrap","webpack://millan.[name]/./src/helpers/cst.ts","webpack://millan.[name]/./src/helpers/types.ts","webpack://millan.[name]/./src/shacl/ShaclParser.ts","webpack://millan.[name]/./src/shacl/index.ts","webpack://millan.[name]/./src/shacl/tokens.ts","webpack://millan.[name]/./src/shacl/visitor.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,CAAC;AACD,O;ACVA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAiB,4BAA4B;AAC7C;AACA;AACA,0BAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAgB,uBAAuB;AACvC;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;ACtJA;AAAA;AAAA;AAAA;AAAA,gBAAgB,SAAI,IAAI,SAAI;AAC5B;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,oCAAoC;AACpC;AACA;AACA,CAAC;AACD;AACA,yBAAyB,4BAA4B,aAAa,EAAE;AACpE,iCAAiC,oBAAoB;AACrD;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8BAA8B;AACrE,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyD;AAClD;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACsC;;;;;;;;;;;;;ACTtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,gBAAgB,SAAI,IAAI,SAAI;AAC5B;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACV;AACI;AAChD,SAAS,mBAAO,CAAC,uCAAU;AAC3B,qBAAqB,mBAAO,CAAC,gDAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa,2BAA2B;AAC1E,gDAAgD,yCAAyC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qEAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,sCAAsC,+CAA+C,EAAE;AACvF,iBAAiB;AACjB;AACA,sCAAsC,2CAA2C,EAAE;AACnF,iBAAiB;AACjB;AACA,sCAAsC,6CAA6C,EAAE;AACrF,iBAAiB;AACjB;AACA,sCAAsC,+CAA+C,EAAE;AACvF,iBAAiB;AACjB;AACA,sCAAsC,oDAAoD,EAAE;AAC5F,iBAAiB;AACjB;AACA,sCAAsC,uDAAuD,EAAE;AAC/F,iBAAiB;AACjB;AACA,sCAAsC,2DAA2D,EAAE;AACnG,iBAAiB;AACjB;AACA,sCAAsC,qDAAqD,EAAE;AAC7F,iBAAiB;AACjB;AACA,sCAAsC,4CAA4C,EAAE;AACpF,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,sCAAsC,uDAAuD,EAAE;AAC/F,iBAAiB;AACjB;AACA,sCAAsC,2DAA2D,EAAE;AACnG,iBAAiB;AACjB;AACA,sCAAsC,+DAA+D,EAAE;AACvG,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,gDAAgD,EAAE;AACxF,iBAAiB;AACjB;AACA,sCAAsC,+CAA+C,EAAE;AACvF,iBAAiB;AACjB;AACA,sCAAsC,kDAAkD,EAAE;AAC1F,iBAAiB;AACjB;AACA,sCAAsC,8CAA8C,EAAE;AACtF,iBAAiB;AACjB;AACA,sCAAsC,iDAAiD,EAAE;AACzF,iBAAiB;AACjB;AACA,sCAAsC,gDAAgD,EAAE;AACxF,iBAAiB;AACjB;AACA,sCAAsC,gDAAgD,EAAE;AACxF,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,iCAAiC,EAAE;AACzE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,4CAA4C,oDAAoD,EAAE;AAClG,sCAAsC,gDAAgD,EAAE;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA,uDAAuD,mGAAmG;AAC1J,sCAAsC,gDAAgD,EAAE;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,gDAAgD,EAAE;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,gDAAgD,EAAE;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,gDAAgD,EAAE;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,gDAAgD,EAAE;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,gDAAgD,EAAE;AACxF,iBAAiB;AACjB;AACA;AACA,sCAAsC,mDAAmD,EAAE;AAC3F,iBAAiB;AACjB;AACA,sCAAsC,+DAA+D,EAAE;AACvG,iBAAiB;AACjB;AACA,sCAAsC,uDAAuD,EAAE;AAC/F,iBAAiB;AACjB;AACA,sCAAsC,oDAAoD,EAAE;AAC5F,iBAAiB;AACjB;AACA,sCAAsC,uDAAuD,EAAE;AAC/F,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,8CAA8C,EAAE;AACtF,iBAAiB;AACjB;AACA,sCAAsC,6CAA6C,EAAE;AACrF,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,wDAAwD,EAAE;AAChG,iBAAiB;AACjB;AACA,sCAAsC,qDAAqD,EAAE;AAC7F,iBAAiB;AACjB;AACA,wCAAwC;AACxC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8CAA8C,EAAE;AAC1F,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8CAA8C,EAAE;AAC1F,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,2CAA2C,EAAE;AACnF,iBAAiB;AACjB;AACA,sCAAsC,4CAA4C,EAAE;AACpF,iBAAiB;AACjB;AACA,sCAAsC,6CAA6C,EAAE;AACrF,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,uDAAuD,EAAE;AAC/F,iBAAiB;AACjB;AACA,sCAAsC,4DAA4D,EAAE;AACpG,iBAAiB;AACjB;AACA,sCAAsC,0DAA0D,EAAE;AAClG,iBAAiB;AACjB;AACA,sCAAsC,qEAAqE,EAAE;AAC7G,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,qDAAqD,EAAE;AAC7F,iBAAiB;AACjB;AACA,sCAAsC,oDAAoD,EAAE;AAC5F,iBAAiB;AACjB;AACA,sCAAsC,sDAAsD,EAAE;AAC9F,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,iCAAiC,EAAE;AACzE,iBAAiB;AACjB;AACA,sCAAsC,mDAAmD,EAAE;AAC3F,iBAAiB;AACjB;AACA,sCAAsC,uCAAuC,EAAE;AAC/E,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,wCAAwC,EAAE;AAChF,iBAAiB;AACjB;AACA,sCAAsC,qCAAqC,EAAE;AAC7E,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,iCAAiC,EAAE;AACzE,iBAAiB;AACjB;AACA,sCAAsC,qCAAqC,EAAE;AAC7E,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,gDAAK;AAC/B;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,CAAC,CAAC,iEAAY;AACS;;;;;;;;;;;;;AC1gBvB;AAAA;AAAA;AAAA;AAAA;AAA8B;AAC9B;AACA,uDAAuD;AAChD,kBAAkB,mBAAO,CAAC,uCAAU;;;;;;;;;;;;;ACH3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAgB,SAAI,IAAI,SAAI;AAC5B;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAO,CAAC,gDAAkB;AACnC,qBAAqB,mBAAO,CAAC,gDAAkB;AACC;AACd;AACc;AACP;AACzC;AACA;AACA;AACO;AACP,4BAA4B,8DAAW;AACvC;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,8BAA8B,8DAAW;AACzC;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,iBAAiB,8DAAW;AAC5B;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,wBAAwB,8DAAW;AACnC;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,uCAAuC,8DAAW;AAClD;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,+BAA+B,8DAAW;AAC1C;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,4BAA4B,8DAAW;AACvC;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,6BAA6B,8DAAW;AACxC;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,+BAA+B,8DAAW;AAC1C;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL;AACO,uEAAuE,8BAA8B,EAAE;AAC9G;AACA,4BAA4B,qEAAe;AAC3C,8BAA8B,qEAAe;AAC7C,iBAAiB,qEAAe;AAChC,wBAAwB,qEAAe;AACvC,uCAAuC,qEAAe;AACtD,+BAA+B,qEAAe;AAC9C,4BAA4B,qEAAe;AAC3C,6BAA6B,qEAAe;AAC5C,+BAA+B,qEAAe;AAC9C,WAAW,qEAAe;AAC1B;AACA,oBAAoB,qEAAe;AACnC;AACA;AACA;AACA,qDAAqD,kDAAkD,EAAE;AACzG;AACA,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,0CAA0C;AAC1C;AACA,mCAAmC,8DAAW;AAC9C;AACA,iBAAiB,gDAAK;AACtB,KAAK;AACL,sBAAsB,oBAAoB,+DAA+D,8DAAW;AACpH;AACA;AACA;AACA,KAAK;AACL,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAW;AAC9C;AACA,iBAAiB,gDAAK;AACtB;AACA,KAAK;AACL,sBAAsB,oBAAoB,+DAA+D,8DAAW;AACpH;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD,sCAAsC;AACtC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB,2DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,0BAA0B,8DAAW;AACnF;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,0BAA0B,8DAAW;AACnF;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC,EAAE,qDAAW;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,2DAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,iCAAiC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE,qDAAW;;;;;;;;;;;;;ACjOd;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACqD;AACd;AACxC;AACA;AACA;AACA;AACA,qCAAqC,2DAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6DAAS;AAClB,SAAS,6DAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA","file":"millan.shacl.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"shacl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shacl\"] = factory();\n\telse\n\t\troot[\"millan\"] = root[\"millan\"] || {}, root[\"millan\"][\"shacl\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"shacl\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([\"./src/shacl/index.ts\",\"vendors~graphql~shacl~sms~sparql~srs~turtle\",\"vendors~shacl\",\"graphql~shacl~sms~sparql~srs~turtle\",\"shacl~srs~turtle\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexport var traverse = function (root, visit) {\n    _traverse(root, null, visit);\n};\nexport var unsafeTraverse = function (root, visit) {\n    _traverse(root, null, visit, false);\n};\nexport function isCstNode(object) {\n    return Boolean(object && 'name' in object);\n}\nvar TraverseContext = /** @class */ (function () {\n    function TraverseContext(_a) {\n        var node = _a.node, parentCtx = _a.parentCtx;\n        this.node = __assign({}, node);\n        this.parentCtx = __assign({}, parentCtx);\n    }\n    return TraverseContext;\n}());\nvar _traverse = function (root, ctx, visit, visitSafely) {\n    if (ctx === void 0) { ctx = new TraverseContext({ node: root }); }\n    if (visitSafely === void 0) { visitSafely = true; }\n    if (!isCstNode(root)) {\n        // must be a token\n        return visit(visitSafely ? __assign({}, ctx) : ctx);\n    }\n    // is a grammar rule node\n    var children = root.children;\n    Object.keys(children).forEach(function (key) {\n        var childType = children[key];\n        if (!childType.length) {\n            return;\n        }\n        childType.forEach(function (child) {\n            var childCtx = visitSafely\n                ? new TraverseContext({ node: child, parentCtx: ctx })\n                : { node: child, parentCtx: ctx };\n            var afterVisit = function (transformedCtx) {\n                var nextCtx = childCtx;\n                if (transformedCtx) {\n                    nextCtx = visitSafely\n                        ? new TraverseContext({\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        })\n                        : {\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        };\n                }\n                _traverse(child, nextCtx, visit, visitSafely);\n            };\n            visit(childCtx, afterVisit);\n        });\n    });\n};\n","import { IToken, CstNode, TokenType, } from 'chevrotain';\nexport var getAsTypedTuple = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args;\n};\n// exported for convenience\nexport { IToken, CstNode, TokenType };\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { TurtleParser } from '../turtle/TurtleParser';\nimport { Lexer, Parser, } from 'chevrotain';\nimport { getShaclVisitor } from 'shacl/visitor';\nvar _a = require('./tokens'), getShaclTokenTypes = _a.getShaclTokenTypes, getShaclTokenMap = _a.getShaclTokenMap, categoryTokenMap = _a.categoryTokenMap;\nvar turtleTokenMap = require('../turtle/tokens').turtleTokenMap;\n// A SHACL parser for the Turtle serialization of SHACL only. The parser can\n// can accept any arbitrary namespace prefix for SHACL/XSD and still tokenize\n// and parse the document correctly (it will also, of course, parse docuemnts\n// using the full SHACL/XSD IRIs). The parser runs both a parse phase and a\n// second validation phase (using a visitor) in order to accommodate SHACL\n// rules that are not purely syntactic.\nvar ShaclParser = /** @class */ (function (_super) {\n    __extends(ShaclParser, _super);\n    function ShaclParser(config, prefixes) {\n        if (prefixes === void 0) { prefixes = { shacl: 'sh', xsd: 'xsd' }; }\n        var _this = _super.call(this, __assign({ outputCst: true, recoveryEnabled: true }, config), getShaclTokenTypes(prefixes), getShaclTokenTypes(prefixes), false) || this;\n        // Some SHACL rules cannot be checked for violations during the first parse.\n        // The visitor accepts the CST that results from parsing and checks\n        // conformity with these SHACL rules.\n        _this.validateWithVisitor = function (cst) {\n            // To save resources while parsing, the shaclVisitor is a singleton.\n            if (!_this.shaclVisitor) {\n                var BaseSrsVisitor = _this.getBaseCstVisitorConstructorWithDefaults();\n                _this.shaclVisitor = getShaclVisitor(BaseSrsVisitor);\n            }\n            else {\n                _this.shaclVisitor.$resetState();\n            }\n            _this.shaclVisitor.visit(cst);\n            return _this.shaclVisitor.$validateShapes(_this.prefixes);\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        _this.parse = function (document) {\n            _this.input = _this.tokenize(document);\n            var cst = _this.turtleDoc();\n            var validationErrors = _this.validateWithVisitor(cst).validationErrors;\n            // Next two items are copied so that they can be returned/held after parse\n            // state is cleared.\n            var errors = _this.errors.slice();\n            var semanticErrors = _this.semanticErrors.concat(validationErrors);\n            return {\n                errors: errors,\n                semanticErrors: semanticErrors,\n                cst: cst,\n            };\n        };\n        _this.predicateObjectList = _this.OVERRIDE_RULE('predicateObjectList', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.shaclRulePredicateObjectList);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.verb);\n                        _this.SUBRULE(_this.objectList);\n                    },\n                },\n            ]);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.OR1([\n                        {\n                            ALT: function () {\n                                _this.SUBRULE1(_this.shaclRulePredicateObjectList);\n                            },\n                        },\n                        {\n                            ALT: function () {\n                                _this.SUBRULE1(_this.verb);\n                                _this.SUBRULE1(_this.objectList);\n                            },\n                        },\n                    ]);\n                });\n            });\n        });\n        _this.shaclRulePredicateObjectList = _this.RULE('shaclRulePredicateObjectList', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPredicateIRI); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclNodeKind); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclTargetNode); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPropertyPath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLiteralConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeExpectingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclHasValueConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclVerbShape); },\n                },\n            ]);\n        });\n        _this.shaclPredicateIRI = _this.RULE('shaclPredicateIRI', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.CONSUME(categoryTokenMap.SingleIriTakingPredicate);\n                        _this.SUBRULE(_this.iri);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.CONSUME(categoryTokenMap.ManyIriTakingPredicate);\n                        _this.SUBRULE1(_this.iri);\n                        _this.MANY(function () {\n                            _this.CONSUME(turtleTokenMap.Comma);\n                            _this.SUBRULE2(_this.iri);\n                        });\n                    },\n                },\n            ]);\n        });\n        _this.shaclNodeKind = _this.RULE('shaclNodeKind', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_nodeKind);\n            _this.CONSUME(categoryTokenMap.NodeKindIRI);\n        });\n        _this.shaclTargetNode = _this.RULE('shaclTargetNode', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_targetNode);\n            _this.SUBRULE(_this.shaclIRIOrLiteral);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.shaclIRIOrLiteral);\n            });\n        });\n        _this.shaclVerbShape = _this.RULE('shaclVerbShape', function () {\n            _this.SUBRULE(_this.verb);\n            _this.SUBRULE(_this.shaclShapeType);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.shaclShapeType);\n            });\n        });\n        _this.shaclShapeType = _this.RULE('shaclShapeType', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_Shape); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_NodeShape); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_PropertyShape); },\n                },\n            ]);\n        });\n        _this.shaclPropertyPath = _this.RULE('shaclPropertyPath', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_path);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n        });\n        _this.shaclPropertyPathPath = _this.RULE('shaclPropertyPathPath', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPredicatePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclSequencePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclAlternativePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclInversePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclZeroOrMorePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclOneOrMorePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclZeroOrOnePath); },\n                },\n            ]);\n        });\n        _this.shaclPredicatePath = _this.RULE('shaclPredicatePath', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    // This case does not seem to be allowed by the SHACL spec, but the\n                    // online W3C validator accepts one level of parens wrapping the IRI.\n                    ALT: function () {\n                        _this.CONSUME(turtleTokenMap.LParen);\n                        _this.SUBRULE1(_this.iri);\n                        _this.CONSUME(turtleTokenMap.RParen);\n                    },\n                },\n            ]);\n        });\n        _this.shaclSequencePath = _this.RULE('shaclSequencePath', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.AT_LEAST_ONE(function () { return _this.SUBRULE1(_this.shaclPropertyPathPath); });\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclAlternativePath = _this.RULE('shaclAlternativePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_alternativePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath); // This does not match the SHACL spec, but it does match the test cases, which violate the spec. ;_;\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclInversePath = _this.RULE('shaclInversePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_inversePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclZeroOrMorePath = _this.RULE('shaclZeroOrMorePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_zeroOrMorePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclOneOrMorePath = _this.RULE('shaclOneOrMorePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_oneOrMorePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclZeroOrOnePath = _this.RULE('shaclZeroOrOnePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_zeroOrOnePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclLiteralConstraint = _this.RULE('shaclLiteralConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclIntConstraint); },\n                },\n                // TODO: Some specificity here is possibly unnecessary -- e.g., maybe `shaclStringConstraint` and `shaclStringLiteralQuoteConstraint` can be consolidated in some way?\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclStringConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclStringLiteralQuoteConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLangStringConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclBooleanConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclAnyLiteralConstraint); },\n                },\n            ]);\n        });\n        _this.shaclIntConstraint = _this.RULE('shaclIntConstraint', function () {\n            _this.CONSUME(categoryTokenMap.IntTakingPredicate);\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.INTEGER); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclXsdInteger); },\n                },\n            ]);\n        });\n        _this.shaclStringConstraint = _this.RULE('shaclStringConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_select); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_ask); },\n                },\n            ]);\n            _this.SUBRULE(_this.String); // TODO: a bit too lax?\n        });\n        _this.shaclStringLiteralQuoteConstraint = _this.RULE('shaclStringLiteralQuoteConstraint', function () {\n            _this.CONSUME(categoryTokenMap.StringLiteralQuoteTakingPredicate);\n            _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE);\n            _this.OPTION(function () {\n                _this.OR([\n                    {\n                        ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n                        },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME1(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_anyURI);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.shaclLangStringConstraint = _this.RULE('shaclLangStringConstraint', function () {\n            _this.CONSUME(categoryTokenMap.LangStringTakingPredicate);\n            _this.SUBRULE(_this.String);\n            _this.OPTION(function () {\n                _this.OR([\n                    {\n                        ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.shaclBooleanConstraint = _this.RULE('shaclBooleanConstraint', function () {\n            _this.CONSUME(categoryTokenMap.BooleanTakingPredicate);\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.TRUE); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.FALSE); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclXsdBoolean); },\n                },\n            ]);\n        });\n        _this.shaclAnyLiteralConstraint = _this.RULE('shaclAnyLiteralConstraint', function () {\n            _this.CONSUME(categoryTokenMap.AnyLiteralTakingPredicate);\n            _this.SUBRULE(_this.literal);\n        });\n        _this.shaclListTakingConstraint = _this.RULE('shaclListTakingConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLanguageInConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclIRIListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeOrLiteralListTakingConstraint); },\n                },\n            ]);\n        });\n        _this.shaclLanguageInConstraint = _this.RULE('shaclLanguageInConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_languageIn);\n            _this.SUBRULE(_this.shaclStringCollection);\n        });\n        _this.shaclStringCollection = _this.RULE('shaclStringCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeListTakingConstraint = _this.RULE('shaclShapeListTakingConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_and); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_or); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_xone); },\n                },\n            ]);\n            _this.SUBRULE(_this.shaclShapeCollection);\n        });\n        _this.shaclShapeCollection = _this.RULE('shaclShapeCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.shaclShape);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclIRIListTakingConstraint = _this.RULE('shaclIRIListTakingConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_ignoredProperties);\n            _this.SUBRULE(_this.shaclIRICollection);\n        });\n        _this.shaclIRICollection = _this.RULE('shaclIRICollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.iri);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeOrLiteralListTakingConstraint = _this.RULE('shaclShapeOrLiteralListTakingConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_in);\n            _this.SUBRULE(_this.shaclShapeOrLiteralCollection);\n        });\n        _this.shaclShapeOrLiteralCollection = _this.RULE('shaclShapeOrLiteralCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.shaclShapeOrLiteral);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeExpectingConstraint = _this.RULE('shaclShapeExpectingConstraint', function () {\n            _this.CONSUME(categoryTokenMap.ShapeExpectingPredicate);\n            _this.SUBRULE(_this.shaclShape);\n        });\n        _this.shaclHasValueConstraint = _this.RULE('shaclHasValueConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_hasValue);\n            _this.SUBRULE(_this.shaclShapeOrLiteral);\n        });\n        _this.shaclShape = _this.RULE('shaclShape', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.blankNodePropertyList); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.BlankNode); },\n                },\n            ]);\n        });\n        _this.shaclShapeOrLiteral = _this.RULE('shaclShapeOrLiteral', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShape); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.literal); },\n                },\n            ]);\n        });\n        _this.shaclIRIOrLiteral = _this.RULE('shaclIRIOrLiteral', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.literal); },\n                },\n            ]);\n        });\n        _this.shaclXsdBoolean = _this.RULE('shaclXsdBoolean', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_boolean);\n        });\n        _this.shaclXsdString = _this.RULE('shaclXsdString', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n        });\n        _this.shaclXsdInteger = _this.RULE('shaclXsdInteger', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_integer);\n        });\n        _this.shaclXsdDate = _this.RULE('shaclXsdDate', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_date);\n        });\n        _this.shaclXsdAnyURI = _this.RULE('shaclXsdAnyURI', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_anyURI);\n        });\n        _this.shaclStringWithDoubleCaret = _this.RULE('shaclStringWithDoubleCaret', function () {\n            _this.SUBRULE(_this.String);\n            _this.CONSUME(turtleTokenMap.DoubleCaret);\n        });\n        _this.prefixes = prefixes;\n        _this.lexer = new Lexer(getShaclTokenTypes(prefixes));\n        _this.shaclTokenMap = getShaclTokenMap(prefixes);\n        Parser.performSelfAnalysis(_this);\n        return _this;\n    }\n    return ShaclParser;\n}(TurtleParser));\nexport { ShaclParser };\n","export * from './ShaclParser';\n// Convenience imports/exports that aren't core functionality:\n// NOTE: Tokens MUST be imported using CommonJS syntax; see here: https://github.com/SAP/chevrotain/issues/345\nexport var shaclTokens = require('./tokens');\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar _a = require('../turtle/tokens'), turtleTokenTypes = _a.turtleTokenTypes, turtleTokenMap = _a.turtleTokenMap;\nvar sparqlTokenMap = require('../sparql/tokens').sparqlTokenMap;\nimport { createToken, Lexer } from 'chevrotain';\nimport memoize from 'memoize-one';\nimport { getAsTypedTuple } from 'helpers/types';\nimport isDeepEqual from 'lodash.isequal';\nvar shaclIriNamespace = 'http://www.w3.org/ns/shacl#';\nvar xsdIriNamespace = 'http://www.w3.org/2001/XMLSchema#';\n// Token categories, useful for making the parser rules simpler.\nexport var categoryTokenMap = {\n    ManyIriTakingPredicate: createToken({\n        name: 'ManyIriTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    SingleIriTakingPredicate: createToken({\n        name: 'SingleIriTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    NodeKindIRI: createToken({\n        name: 'NodeKindIRI',\n        pattern: Lexer.NA,\n    }),\n    IntTakingPredicate: createToken({\n        name: 'IntTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    StringLiteralQuoteTakingPredicate: createToken({\n        name: 'StringLiteralQuoteTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    LangStringTakingPredicate: createToken({\n        name: 'LangStringTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    BooleanTakingPredicate: createToken({\n        name: 'BooleanTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    ShapeExpectingPredicate: createToken({\n        name: 'ShapeExpectingPredicate',\n        pattern: Lexer.NA,\n    }),\n    AnyLiteralTakingPredicate: createToken({\n        name: 'AnyLiteralTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n};\nexport var categoryTokens = Object.keys(categoryTokenMap).map(function (key) { return categoryTokenMap[key]; });\nvar localNamesByCategory = {\n    ManyIriTakingPredicate: getAsTypedTuple('equals', 'disjoint', 'lessThan', 'lessThanOrEquals', 'targetClass', 'targetSubjectsOf', 'targetObjectsOf'),\n    SingleIriTakingPredicate: getAsTypedTuple('class', 'datatype', 'severity'),\n    NodeKindIRI: getAsTypedTuple('IRI', 'BlankNode', 'Literal', 'BlankNodeOrIRI', 'BlankNodeOrLiteral', 'IRIOrLiteral'),\n    IntTakingPredicate: getAsTypedTuple('minCount', 'maxCount', 'minLength', 'maxLength', 'qualifiedMinCount', 'qualifiedMaxCount'),\n    StringLiteralQuoteTakingPredicate: getAsTypedTuple('pattern', 'flags', 'prefix', 'namespace'),\n    LangStringTakingPredicate: getAsTypedTuple('message', 'labelTemplate'),\n    BooleanTakingPredicate: getAsTypedTuple('uniqueLang', 'qualifiedValueShapesDisjoint', 'closed', 'deactivated', 'optional'),\n    ShapeExpectingPredicate: getAsTypedTuple('not', 'node', 'property', 'qualifiedValueShape', 'sparql', 'declare', 'prefixes', 'parameter', 'nodeValidator', 'propertyValidator', 'validator'),\n    AnyLiteralTakingPredicate: getAsTypedTuple('minExclusive', 'minInclusive', 'maxExclusive', 'maxInclusive'),\n    other: getAsTypedTuple('Shape', 'NodeShape', 'PropertyShape', 'targetNode', 'message', 'path', 'alternativePath', 'inversePath', 'zeroOrMorePath', 'oneOrMorePath', 'zeroOrOnePath', 'nodeKind', 'languageIn', 'and', 'or', 'xone', 'ignoredProperties', 'hasValue', 'in', 'select', 'ask'),\n};\nvar xsdLocalNames = getAsTypedTuple('boolean', 'integer', 'string', 'date', 'dateTime', 'anyURI');\n// Map of local names back to their categories, for easier lookup:\nvar localNameToCategoryMap = Object.keys(localNamesByCategory).reduce(function (nameToCategoryMap, category) {\n    var categoryLocalNames = localNamesByCategory[category];\n    categoryLocalNames.forEach(function (localName) { return (nameToCategoryMap[localName] = category); });\n    return nameToCategoryMap;\n}, {});\nvar localNames = Object.keys(localNameToCategoryMap);\n// We can pre-compute all tokens for the `xsd` namespace except for those that\n// include prefixes (since we don't know a priori what the prefix will be).\n// For each XSD local name, we will create a \"category\" token that will\n// ultimately be used as the single token encompassing either the full\n// (un-prefixed) IRI or the prefixed name (i.e., `xsd:string). At this point,\n// we create only the category token and the full (un-prefixed) IRI token; the\n// prefixed token is created later (via `getShaclTokenTypes`) once we actually\n// know what the `xsd` prefix is.\nvar xsdUnprefixedTokenMap = xsdLocalNames.reduce(function (tokenMap, localName) {\n    var _a;\n    var tokenName = \"SHACL_xsd_\" + localName; // category token name\n    var iriTokenName = tokenName + \"_IRI\"; // IRI token name\n    // Category token that will ultimately select either an XSD IRI or an XSD PN_LOCAL:\n    var iriOrPrefixCategoryToken = createToken({\n        name: tokenName,\n        pattern: Lexer.NA,\n    });\n    return __assign({}, tokenMap, (_a = {}, _a[tokenName] = iriOrPrefixCategoryToken, _a[iriTokenName] = createToken({\n        name: iriTokenName,\n        pattern: \"<\" + xsdIriNamespace + localName,\n        categories: [iriOrPrefixCategoryToken, turtleTokenMap.IRIREF],\n    }), _a));\n}, {});\n// We can also pre-compute all SHACL tokens except for those that include\n// prefixes (again, since we don't know a priori what the SHACL prefix will be).\n// This helps keep our parser quick. We do it in the same way that we did for\n// XSD tokens, above -- we create a \"category\" token for each SHACL local name\n// that will be used to match either the full (un-prefixed) IRI or the prefixed\n// name (once we know what the SHACL prefix is).\nvar shaclUnprefixedTokenMap = localNames.reduce(function (tokenMap, localName) {\n    var _a;\n    var category = localNameToCategoryMap[localName];\n    var categoryToken = categoryTokenMap[category];\n    var tokenName = \"SHACL_\" + localName;\n    var iriTokenName = tokenName + \"_IRI\";\n    // Category token that will select either a SHACL IRI or a SHACL PN_LOCAL:\n    var iriOrPrefixCategoryToken = createToken({\n        name: tokenName,\n        pattern: Lexer.NA,\n        categories: categoryToken ? [categoryToken] : [],\n    });\n    return __assign({}, tokenMap, (_a = {}, _a[tokenName] = iriOrPrefixCategoryToken, _a[iriTokenName] = createToken({\n        name: iriTokenName,\n        pattern: \"<\" + shaclIriNamespace + localName + \">\",\n        categories: [iriOrPrefixCategoryToken, turtleTokenMap.IRIREF],\n    }), _a));\n}, xsdUnprefixedTokenMap);\nvar makePrefixer = function (prefix) { return function (localName) {\n    return prefix + \":\" + localName;\n}; };\n// Retrieves the complete map of all SHACL/XSD tokens, given the SHACL and XSD\n// prefixes. The map contains, for every local name, a token matching the full\n// IRI, a token matching the prefixed local name, and a \"category\" token that\n// matches both. The category token is useful for simplifying parser rules (not\n// having to match every SHACL token as both a full IRI and a prefixed local\n// name.)\n// This function is called by the SHACL parser. It is memoized because the\n// arguments are small and unlikely to change often, and the parser needs to be\n// fast, so we should avoid re-computing.\nexport var getShaclTokenMap = memoize(function (prefixes) {\n    var prefixWithShacl = makePrefixer(prefixes.shacl);\n    var prefixWithXsd = makePrefixer(prefixes.xsd);\n    // Add the prefixed local names to the SHACL token map now that we know the\n    // prefixes.\n    var shaclTokenMap = localNames.reduce(function (tokenMap, localName) {\n        var _a;\n        var tokenName = \"SHACL_\" + localName;\n        var prefixedTokenName = tokenName + \"_prefixed\";\n        return __assign({}, tokenMap, (_a = {}, _a[prefixedTokenName] = createToken({\n            name: prefixedTokenName,\n            pattern: prefixWithShacl(localName),\n            categories: [tokenMap[tokenName], turtleTokenMap.PNAME_LN],\n        }), _a));\n    }, shaclUnprefixedTokenMap);\n    // Add the prefixed local names to the XSD token map now that we know the\n    // prefixes.\n    return xsdLocalNames.reduce(function (tokenMap, localName) {\n        var _a;\n        var tokenName = \"SHACL_xsd_\" + localName;\n        var prefixedTokenName = tokenName + \"_prefixed\";\n        return __assign({}, tokenMap, (_a = {}, _a[prefixedTokenName] = createToken({\n            name: prefixedTokenName,\n            pattern: \"\" + prefixWithXsd(localName),\n            categories: [tokenMap[tokenName], turtleTokenMap.PNAME_LN],\n        }), _a));\n    }, shaclTokenMap);\n}, isDeepEqual);\n// Get the index of PNAME_NS and IRIREF so that we can re-use existing Turtle\n// tokens but ensure that our special SHACL/XSD tokens are inserted at the\n// right place (since order of tokens matters for chevrotain).\nvar pnameIndex = turtleTokenTypes.indexOf(sparqlTokenMap.PNAME_NS);\nvar iriIndex = turtleTokenTypes.indexOf(turtleTokenMap.IRIREF);\n// tokenMap keys will need to be sorted in reverse order so that tokens with\n// partial overlap are in the right order in the TokenType array.\nvar reverseSort = function (a, b) {\n    // @ts-ignore: unused variable\n    var _a = a.split('_'), aIgnored = _a[0], aName = _a[1], aRemainder = _a.slice(2);\n    // @ts-ignore: unused variable\n    var _b = b.split('_'), bIgnored = _b[0], bName = _b[1], bRemainder = _b.slice(2);\n    // Grab the local name and lowercase it:\n    var aSortString = (aName === 'xsd' ? aRemainder[0] : aName).toLowerCase();\n    var bSortString = (bName === 'xsd' ? bRemainder[0] : bName).toLowerCase();\n    if (aSortString === bSortString) {\n        // If local names are identical, prefer the one without a suffix to those with suffixes.\n        var aSuffix = aName === 'xsd' ? aRemainder[1] : aRemainder[0];\n        var bSuffix = bName === 'xsd' ? bRemainder[1] : bRemainder[0];\n        if (aSuffix && bSuffix) {\n            return 0; // when both local names have suffixes, treat as lexicographically the same for sorting\n        }\n        else {\n            return aSuffix ? 1 : -1;\n        }\n    }\n    else {\n        return aSortString < bSortString ? 1 : bSortString < aSortString ? -1 : 0;\n    }\n};\n// Given SHACL and XSD prefixes, this method returns an array of Turtle +\n// SHACL/XSD tokens, including tokens for prefixed local names, with the\n// SHACL/XSD tokens inserted at the proper positions so that they are matched\n// before the more generic Turtle tokens.\nexport var getShaclTokenTypes = memoize(function (prefixes) {\n    var tokenMap = getShaclTokenMap(prefixes);\n    var _a = Object.keys(tokenMap)\n        .sort(reverseSort)\n        .reduce(function (accumulator, key) {\n        if (key.endsWith('_IRI')) {\n            if (iriIndex < pnameIndex) {\n                accumulator.iriTokens.push(tokenMap[key.slice(0, -4)]);\n            }\n            accumulator.iriTokens.push(tokenMap[key]);\n        }\n        else if (key.endsWith('_prefixed')) {\n            if (pnameIndex < iriIndex) {\n                accumulator.pnameTokens.push(tokenMap[key.slice(0, -9)]);\n            }\n            accumulator.pnameTokens.push(tokenMap[key]);\n        }\n        return accumulator;\n    }, { pnameTokens: [], iriTokens: [] }), pnameTokens = _a.pnameTokens, iriTokens = _a.iriTokens;\n    if (pnameIndex < iriIndex) {\n        return turtleTokenTypes.slice(0, pnameIndex).concat(categoryTokens, pnameTokens, turtleTokenTypes.slice(pnameIndex, iriIndex), iriTokens, turtleTokenTypes.slice(iriIndex));\n    }\n    else {\n        return turtleTokenTypes.slice(0, iriIndex).concat(categoryTokens, iriTokens, turtleTokenTypes.slice(iriIndex, pnameIndex), pnameTokens, turtleTokenTypes.slice(pnameIndex));\n    }\n}, isDeepEqual);\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport escapeStringRegexp from 'escape-string-regexp';\nimport { isCstNode } from 'helpers/cst';\n// Given a SHACL prefix, returns a RegExp that can be used for grabbing the\n// local name (e.g., the 'NodeShape' in 'sh:NodeShape') from either a full\n// SHACL IRI or a prefixed local name.\nvar getShaclLocalNameMatcher = function (shaclPrefix) {\n    return new RegExp(\"(?:shacl#|\" + escapeStringRegexp(shaclPrefix) + \":)(\\\\S+?)>?$\");\n};\n// Traverses the tree of descendants for a given CstNode until a token is\n// found. Returns the \"start\" token for the CstNode (i.e., the earliest token\n// encompassed by the CstNode). This is useful for diagnostics.\nvar getUnderlyingStartToken = function (ctx) {\n    var currentNode = ctx;\n    while (currentNode.children) {\n        var currentNodeKey = Object.keys(currentNode.children)[0];\n        currentNode = currentNode.children[currentNodeKey][0];\n    }\n    return currentNode;\n};\n// Grabs the local name (e.g., the 'NodeShape' in 'sh:NodeShape') from either\n// a full SHACL IRI or a prefixed local name, if it is available.\nvar getLocalName = function (iri, matcher) {\n    var result = matcher.exec(iri);\n    if (result) {\n        return result[1];\n    }\n};\n// Given an initial (possibly partially complete) `shape` object and an array\n// of CstElements matching the `shaclRulePredicateObjectList` grammar rule,\n// transforms the `shape` into a complete `ShaclShape` with associated SHACL\n// types and predicates.\n// NOTE: mutates `shape`!\nvar addPredicatesAndTypesToShape = function (shape, shaclRulePredicateObjectListNodes) {\n    shaclRulePredicateObjectListNodes.forEach(function (node) {\n        var child = node.children[Object.keys(node.children)[0]][0];\n        switch (child.name) {\n            case 'shaclVerbShape': {\n                var token = getUnderlyingStartToken(child);\n                var verbTokenInsensitive = token.image.toLowerCase();\n                var isTypeVerb = verbTokenInsensitive === 'a' ||\n                    verbTokenInsensitive === 'rdf:type' ||\n                    verbTokenInsensitive ===\n                        '<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>';\n                if (!isTypeVerb) {\n                    return;\n                }\n                Object.keys(child.children).forEach(function (key) {\n                    if (key !== 'shaclShapeType') {\n                        return;\n                    }\n                    var shapeTypeNode = child.children[key][0];\n                    if (shapeTypeNode.children.SHACL_NodeShape) {\n                        shape.types.push({\n                            type: 'NodeShape',\n                            token: getUnderlyingStartToken(shapeTypeNode),\n                        });\n                    }\n                    else if (shapeTypeNode.children.SHACL_PropertyShape) {\n                        shape.types.push({\n                            type: 'PropertyShape',\n                            token: getUnderlyingStartToken(shapeTypeNode),\n                        });\n                    }\n                });\n                break;\n            }\n            case 'shaclPredicateIRI': {\n                if (child.children.SingleIriTakingPredicate) {\n                    shape.predicates.push({\n                        type: 'SingleIriTakingPredicate',\n                        token: getUnderlyingStartToken(child.children\n                            .SingleIriTakingPredicate[0]),\n                    });\n                }\n                else if (child.children.ManyIriTakingPredicate) {\n                    shape.predicates.push({\n                        type: 'ManyIriTakingPredicate',\n                        token: getUnderlyingStartToken(child.children\n                            .ManyIriTakingPredicate[0]),\n                    });\n                }\n                break;\n            }\n            case 'shaclNodeKind':\n                shape.predicates.push({\n                    type: 'nodeKind',\n                    token: child.children.SHACL_nodeKind[0],\n                });\n                break;\n            case 'shaclTargetNode':\n                shape.predicates.push({\n                    type: 'targetNode',\n                    token: child.children.SHACL_targetNode[0],\n                });\n                break;\n            case 'shaclPropertyPath':\n                shape.predicates.push({\n                    type: 'path',\n                    token: child.children.SHACL_path[0],\n                });\n                break;\n            case 'shaclLiteralConstraint':\n                shape.predicates.push({\n                    type: 'LiteralConstraint',\n                    token: getUnderlyingStartToken(child),\n                });\n                break;\n            case 'shaclListTakingConstraint':\n                shape.predicates.push({\n                    type: 'ListTakingConstraint',\n                    token: getUnderlyingStartToken(child),\n                });\n                break;\n            case 'shaclShapeExpectingConstraint':\n                shape.predicates.push({\n                    type: 'ShapeExpectingPredicate',\n                    token: child.children.ShapeExpectingPredicate[0],\n                });\n                break;\n            case 'shaclHasValueConstraint':\n                shape.predicates.push({\n                    type: 'hasValue',\n                    token: child.children.SHACL_hasValue[0],\n                });\n                break;\n            default:\n                console.log(\"SHACL predicateObjectList with name \" + child.name + \" not recognized.\");\n        }\n    });\n};\n// Utility method for constructing a `ShaclShape` from CstElements matching the\n// `shaclShape` grammar rule.\nvar getShaclShapeFromBlankNodePropertyList = function (ctx) {\n    var blankNodeNode = ctx.blankNodePropertyList[0];\n    var predicateObjectListNode = blankNodeNode.children.predicateObjectList[0];\n    var optionalPredicateObjectListNode = ctx.predicateObjectList\n        ? ctx.predicateObjectList[0]\n        : null;\n    if (!isCstNode(predicateObjectListNode) &&\n        !isCstNode(optionalPredicateObjectListNode)) {\n        return;\n    }\n    var shaclRulePredicateObjectListNodes = optionalPredicateObjectListNode &&\n        optionalPredicateObjectListNode.children &&\n        optionalPredicateObjectListNode.children.shaclRulePredicateObjectList\n        ? (predicateObjectListNode.children.shaclRulePredicateObjectList ||\n            []).concat(optionalPredicateObjectListNode.children\n            .shaclRulePredicateObjectList) : predicateObjectListNode.children.shaclRulePredicateObjectList;\n    if (!shaclRulePredicateObjectListNodes) {\n        return;\n    }\n    var shape = {\n        subject: {\n            type: 'blankNodePropertyList',\n            token: getUnderlyingStartToken(blankNodeNode),\n        },\n        types: [],\n        predicates: [],\n    };\n    addPredicatesAndTypesToShape(shape, shaclRulePredicateObjectListNodes);\n    return shape;\n};\n// Returns a new SHACL visitor that extends that given BaseVisitor. The SHACL\n// visitor is capable of constructing ShaclShape objects from a given CST and\n// then using those shapes to perform validations that cannot be performed in\n// the initial parse of a SHACL document.\nexport var getShaclVisitor = function (BaseVisitor) {\n    var ShaclVisitor = /** @class */ (function (_super) {\n        __extends(ShaclVisitor, _super);\n        function ShaclVisitor() {\n            var _this = _super.call(this) || this;\n            // `triples` have two alternatives, one with a `subject` and one with a\n            // `blankNodePropertyList`. This method constructs SHACL shapes for each\n            // alternative.\n            _this.triples = function (ctx) {\n                if (ctx.subject) {\n                    var predicateObjectListNode = ctx.predicateObjectList[0];\n                    if (!isCstNode(predicateObjectListNode)) {\n                        return;\n                    }\n                    var shaclRulePredicateObjectListNodes = predicateObjectListNode.children.shaclRulePredicateObjectList;\n                    if (!shaclRulePredicateObjectListNodes) {\n                        return;\n                    }\n                    var shape = {\n                        subject: {\n                            type: Object.keys(ctx.subject[0].children)[0] === 'collection'\n                                ? 'collection'\n                                : 'subject',\n                            token: getUnderlyingStartToken(ctx.subject[0]),\n                        },\n                        types: [],\n                        predicates: [],\n                    };\n                    addPredicatesAndTypesToShape(shape, shaclRulePredicateObjectListNodes);\n                    _this.shapes.push(shape);\n                    _this.visit(ctx.subject);\n                    _this.visit(predicateObjectListNode);\n                }\n                else {\n                    var shape = getShaclShapeFromBlankNodePropertyList(ctx);\n                    if (!shape) {\n                        return;\n                    }\n                    _this.shapes.push(shape);\n                    _this.visit(ctx.blankNodePropertyList);\n                    if (ctx.predicateObjectList) {\n                        _this.visit(ctx.predicateObjectList);\n                    }\n                }\n            };\n            // Some SHACL shapes (e.g., nested PropertyShapes) are not matched\n            // by the `triples` grammar rule; instead, they match `shapeShape`.\n            _this.shaclShape = function (ctx) {\n                if (!ctx.blankNodePropertyList) {\n                    // Not an inline shape we need to traverse, just an identifier.\n                    return;\n                }\n                var shape = getShaclShapeFromBlankNodePropertyList(ctx);\n                if (!shape) {\n                    return;\n                }\n                _this.shapes.push(shape);\n                _this.visit(ctx.blankNodePropertyList);\n            };\n            _this.$resetState = function () {\n                _this.shapes = [];\n            };\n            _this.$validateShapes = function (_a) {\n                var shaclPrefix = _a.shacl;\n                var validationErrors = [];\n                var localNameMatcher = getShaclLocalNameMatcher(shaclPrefix);\n                var bnodeCount = 0;\n                var shapesConsolidatedBySubject = _this.shapes.reduce(function (consolidatedShapes, shape) {\n                    var image = shape.subject.token.image;\n                    var subjectImage = image === '[' ? \"bnode\" + ++bnodeCount : image;\n                    if (!consolidatedShapes[subjectImage]) {\n                        consolidatedShapes[subjectImage] = {\n                            subjects: [shape.subject],\n                            types: shape.types,\n                            predicates: shape.predicates,\n                        };\n                    }\n                    else {\n                        var consolidatedShape = consolidatedShapes[subjectImage];\n                        consolidatedShapes[subjectImage] = {\n                            subjects: consolidatedShape.subjects.concat([shape.subject]),\n                            types: consolidatedShape.types.concat(shape.types),\n                            predicates: consolidatedShape.predicates.concat(shape.predicates),\n                        };\n                    }\n                    return consolidatedShapes;\n                }, {});\n                Object.keys(shapesConsolidatedBySubject).forEach(function (subjectImage) {\n                    var _a = shapesConsolidatedBySubject[subjectImage], subjects = _a.subjects, types = _a.types, predicates = _a.predicates;\n                    var shapeType;\n                    types.forEach(function (_a) {\n                        var type = _a.type;\n                        if (shapeType && type !== shapeType) {\n                            validationErrors.push({\n                                name: 'ShapeTypeError',\n                                message: 'A SHACL shape can be at most one of NodeShape or PropertyShape.',\n                                token: subjects[0].token,\n                            });\n                        }\n                        else if (!shapeType) {\n                            shapeType = type;\n                        }\n                    });\n                    var pathPredicates = [];\n                    var nonPathPredicateMap = {};\n                    predicates.forEach(function (predicate) {\n                        var image = predicate.token.image;\n                        var localName = getLocalName(image, localNameMatcher);\n                        var predicateImage = localName\n                            ? shaclPrefix + \":\" + localName\n                            : image;\n                        if (predicateImage === shaclPrefix + \":path\") {\n                            pathPredicates.push(predicate);\n                        }\n                        else {\n                            if (!nonPathPredicateMap[predicateImage]) {\n                                nonPathPredicateMap[predicateImage] = [];\n                            }\n                            nonPathPredicateMap[predicateImage].push(predicate);\n                        }\n                    });\n                    if (pathPredicates.length > 0) {\n                        if (shapeType === 'NodeShape') {\n                            validationErrors.push({\n                                name: 'ShapePropertyError',\n                                message: 'SHACL instances of `NodeShape` cannot have a value for the `path` property.',\n                                token: pathPredicates[0].token,\n                            });\n                        }\n                        else {\n                            shapeType = 'PropertyShape';\n                        }\n                        if (pathPredicates.length > 1) {\n                            validationErrors.push({\n                                name: 'ShapePropertyError',\n                                message: 'A shape can have at most one value for sh:path.',\n                                token: pathPredicates[1].token,\n                            });\n                        }\n                    }\n                    if (shapeType === 'NodeShape') {\n                        [\n                            'minCount',\n                            'maxCount',\n                            'uniqueLang',\n                            'lessThan',\n                            'lessThanOrEquals',\n                            'qualifiedValueShape',\n                        ].forEach(function (image) {\n                            var prefixedImage = shaclPrefix + \":\" + image;\n                            if (nonPathPredicateMap[prefixedImage]) {\n                                validationErrors.push({\n                                    name: 'ShapePropertyError',\n                                    message: \"A NodeShape cannot have any value for \" + prefixedImage + \".\",\n                                    token: nonPathPredicateMap[prefixedImage][0].token,\n                                });\n                            }\n                        });\n                    }\n                    else {\n                        [\n                            'deactivated',\n                            'severity',\n                            'datatype',\n                            'nodeKind',\n                            'minCount',\n                            'maxCount',\n                            'minExclusive',\n                            'minInclusive',\n                            'maxExclusive',\n                            'maxInclusive',\n                            'minLength',\n                            'maxLength',\n                            'languageIn',\n                            'uniqueLang',\n                            'in',\n                        ].forEach(function (image) {\n                            var prefixedImage = shaclPrefix + \":\" + image;\n                            if (nonPathPredicateMap[prefixedImage] &&\n                                nonPathPredicateMap[prefixedImage].length > 1) {\n                                validationErrors.push({\n                                    name: 'ShapePropertyError',\n                                    message: \"A shape can have at most one value for \" + prefixedImage + \".\",\n                                    token: nonPathPredicateMap[prefixedImage][1].token,\n                                });\n                            }\n                        });\n                    }\n                });\n                return { validationErrors: validationErrors };\n            };\n            _this.validateVisitor();\n            _this.shapes = [];\n            return _this;\n        }\n        return ShaclVisitor;\n    }(BaseVisitor));\n    return new ShaclVisitor();\n};\n"],"sourceRoot":""}